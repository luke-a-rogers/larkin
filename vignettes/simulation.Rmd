---
title: "simulation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{simulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(larkin)
library(ggplot2)
library(patchwork)
```

## Purpose

Hi Ann-Marie, Carrie and Andy, 

I simulated 1000 years of sockeye salmon abundance data from a Larkin 
simulation model. My hope is that we can look at the model and data, and decide 
whether the spawner dynamics look realistic enough to use the simulation 
in testing our EDM forecasting methods.

The model uses brood spawners and the previous three years of spawners to 
simulate age-specific recruitment (ages 3-5). The age-at-maturity proportions 
are stochastic, and the process errors are autocorrelated. A constant harvest 
rate is applied after recruits are enumerated. The next spawners are the sum
of recruits ages 3-5 after harvest that return in the corresponding year.

The simulation model follows the general form of the simulation model 
`EDMsimulate::salmon_sim()` with two key differences. First, this simulation 
model outputs recruitment at age by brood year, while `salmon_sim()` outputs 
total recruitment by return year. Second, this simulation model computes
stochastic values sequentially so that a longer version of a simulation that 
exactly replicates the existing values can be reproduced, by specifying the 
same `seed` argument. By contrast, `salmon_sim()` computes stochastic values 
in blocks by parameter type and consequently lengthening the simulation changes 
previous values even if `set.seed()` is specified.

Can you have a look and let me know whether anything catches your eye or needs 
improving (especially in the parameter values or simulation function)?

Thanks!

Luke


## Parameter values
I was surprised that simulation values were robust to different initial spawner 
abundances (as long as a given `seed` was specified). For example, the values 
of simulations with the intial spawner abundances `rep(1, 8)` and 
`c(25, 5, 1, 1, 25, 5, 1, 1) * 0.05` converged after roughly 100 iterations.

```{r par-values}
# s1 <- sim(
#   a = 7, # Per-capita population growth rate at low spawner abundance
#   b = rep(1, 4), # Density dependence parameters for spawners and lags
#   init = rep(1, 8), # Initial spawner abundances
#   h = 0.2, # Constant harvest rate
#   p_bar = c(0.003, 0.917, 0.08), # Age at maturity mean proportions
#   omega = 0.6, # Age at maturity proportion deviation parameter
#   rho = 0.5, # Process error autocorrelation parameter
#   sigma = 0.8, # Process error standard deviation parameter
#   phi_1 = 0.1, # Initial process error deviation
#   burn = 100, # Number of burn-in steps before the simulation
#   span = 1000, # Number of steps in the simulation
#   seed = 109 # Seed value for set.seed()
# )

```

## Simulation figure
The panels show the first 100 simulated spawner abundances after burn-in (top),
and first 1000 (bottom). I distinguished the brood lines by colour to show the 
changes in cyclic dominance over time (top only).

```{r sim-figure, fig.width = 7.15, fig.height = 5, fig.retina = 2, fig.cap = "Simulated spawner abundance during first 100 time steps (top) and first 1000 time steps (bottom)."}
# 
# p1 <- ggplot(s1[1:100, ]) +
#   geom_line(aes(x = seq_along(S), y = S)) +
#   geom_point(aes(x = seq_along(S), y = S, color = factor(rep(1:4, 25)))) +
#   scale_color_grey() +
#   labs(x = "Time", y = expression(Spawners~(10^6)), color = "Brood line") +
#   theme_bw()
# 
# p2 <- ggplot(s1, aes(x = seq_along(S), y = S)) +
#   geom_line() +
#   labs(x = "Time", y = expression(Spawners~(10^6))) +
#   theme_bw()
#   
# p1 / p2

```


## Simulation function

```{r sim-function} 
#' Simulate Sockeye Dynamics From A Larkin Stock-Recruitment Model
#'
#' @param a [numeric()] per-capita population growth rate at low abundance
#' @param b [numeric()] [vector()] density dependence parameters
#' @param init [numeric()] [vector()] initial spawner abundances
#' @param h [numeric()] constant harvest rate
#' @param p_bar [numeric()] [vector()] mean age at maturity proportions
#' @param omega [numeric()] age at maturity proportion deviation parameter
#' @param rho [numeric()] process error autocorrelation parameter
#' @param sigma [numeric()] process error standard deviation parameter
#' @param phi_1 [numeric()] initial process error deviation
#' @param burn [integer()] number of burn-in steps before the simulation
#' @param span [integer()] number of steps in the simulation
#' @param seed [integer()] passed internally to [set.seed()]
#'
#' @return [data.frame()] simulated spawner and recruitment at age abundances
#'
#' @export
#'
#' @examples
#' s1 <- sim()
#'
sim <- function(
  a = 7,
  b = rep(1, 4),
  init = rep(1, 8),
  h = 0.2,
  p_bar = c(0.003, 0.917, 0.08),
  rho = 0.5,
  omega = 0.6,
  sigma = 0.8,
  phi_1 = 0.1,
  burn = 100,
  span = 1000,
  seed = NULL
) {

  # Set seed -------------------------------------------------------------------

  if (!is.null(seed)) {
    set.seed(seed)
  }

  # Initialize indexes ---------------------------------------------------------

  num_init <- 8L
  num_iter <- num_init + burn + span
  ind_init <- seq_len(num_init)
  ind_data <- (num_init + burn + 1):(num_iter)

  # Instantiate state variables ------------------------------------------------

  S <- rep(NA, num_iter)
  R <- matrix(NA, nrow = num_iter, ncol = 3)
  colnames(R) <- c("R_3", "R_4", "R_5")

  # Initialize state variables -------------------------------------------------

  S[ind_init] <- init

  # Instantiate simulation parameters ------------------------------------------

  p_t <- matrix(NA, nrow = num_iter, ncol = 3)
  phi_t <- rep(NA, num_iter)

  # Simulate state variables ---------------------------------------------------

  for (i in seq_len(num_iter)) {
    # Define age at maturity proportions
    p_numer <- exp(omega * rnorm(3, 0, 1)) * p_bar
    p_denom <- sum(p_numer)
    p_t[i, ] <- p_numer / p_denom
    # Define autocorrelated process error (see Holt and Peterman 2008)
    if (i == 1) {
      phi_t[i] <- phi_1
    } else {
      phi_t[i] <- rho * phi_t[i - 1] + rnorm(1, -sigma^2/2, sigma)
    }
    # Update state variables
    if (i >= 4) {
      R[i, ] <- p_t[i, ] * a * S[i] * exp(sum(-b * S[i:(i - 3)]) + phi_t[i])
    }
    if (i >= 8) {
      S[i + 1] <- (1 - h) * (R[i - 4, 3] + R[i - 3, 2] + R[i - 2, 1])
    }
    if (S[i + 1] < 2e-06) {
      S[i + 1] <- 0
    }
  }

  # Return simulated data ------------------------------------------------------

  N <- data.frame(
    R_3 = R[ind_data, 1],
    R_4 = R[ind_data, 2],
    R_5 = R[ind_data, 3],
    S = S[ind_data]
  )
  return(N)
}

```
